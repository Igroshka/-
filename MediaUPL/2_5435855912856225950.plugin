# -*- coding: utf-8 -*-

__id__ = "profile_local_notes_pg"
__name__ = "Profile Notes"
__description__ = "Позволяет добавлять локальные заметки в профили пользователей, которые отображаются как закреплённое сообщение. Автор идеи: @lisurgut"
__version__ = "1.0.2"
__author__ = "@lisurgut & @PluginIDEbot"
__icon__ = "sPluginIDE/35"
__min_version__ = "11.12.1"

import json
import traceback
from typing import Any, Dict

from base_plugin import BasePlugin, MethodHook
from hook_utils import find_class, get_private_field
from android_utils import log, run_on_ui_thread
from ui.bulletin import BulletinHelper

# Сгенерировано в PluginGRT - @PluginIDEbot

# --- Android UI Imports ---
try:
    View = find_class("android.view.View")
    ViewGroup = find_class("android.view.ViewGroup")
    Context = find_class("android.content.Context")
    Gravity = find_class("android.view.Gravity")
    LinearLayout = find_class("android.widget.LinearLayout")
    FrameLayout = find_class("android.widget.FrameLayout")
    EditText = find_class("android.widget.EditText")
    TextView = find_class("android.widget.TextView")
    ImageView = find_class("android.widget.ImageView")
    Color = find_class("android.graphics.Color")
    Typeface = find_class("android.graphics.Typeface")
    GradientDrawable = find_class("android.graphics.drawable.GradientDrawable")

    # --- Telegram UI Imports ---
    ProfileActivity = find_class("org.telegram.ui.ProfileActivity")
    AndroidUtilities = find_class("org.telegram.messenger.AndroidUtilities")
    LocaleController = find_class("org.telegram.messenger.LocaleController")
    R = find_class("org.telegram.messenger.R")
    
    UI_CLASSES_LOADED = True
except Exception as e:
    log(f"ProfileNotes: Critical error on UI class import: {e}")
    UI_CLASSES_LOADED = False

class ProfileNotesPlugin(BasePlugin):
    def __init__(self):
        super().__init__()
        self.pg_notes_cache: Dict[int, str] = {}
        # Словарь для отслеживания добавленных UI элементов, чтобы избежать дублирования
        self.injected_views: Dict[int, Dict[str, Any]] = {}

    def on_plugin_load(self):
        if not UI_CLASSES_LOADED:
            log("ProfileNotes: Plugin disabled due to missing UI classes.")
            return

        self._load_notes()
        self.log("ProfileNotes plugin loaded successfully.")

        try:
            # Хук на создание View в ProfileActivity
            create_view_method = ProfileActivity.getDeclaredMethod("createView", Context)
            self.hook_method(create_view_method, ProfileCreateViewHook(self))

            # Хук на уничтожение фрагмента для очистки
            on_destroy_method = ProfileActivity.getDeclaredMethod("onFragmentDestroy")
            self.hook_method(on_destroy_method, ProfileDestroyHook(self))

        except Exception as e:
            self.log(f"Failed to apply hooks: {e}\n{traceback.format_exc()}")
            run_on_ui_thread(lambda: BulletinHelper.show_error(f"ProfileNotes Hook Error: {e}"))

    # --- Управление данными ---
    def _load_notes(self):
        """Загружает все заметки из настроек в кеш."""
        try:
            notes_json = self.get_setting("user_notes", "{}")
            # Конвертируем ключи из строк обратно в int
            self.pg_notes_cache = {int(k): v for k, v in json.loads(notes_json).items()}
        except (json.JSONDecodeError, TypeError):
            self.pg_notes_cache = {}
            self.log("Could not decode notes, starting fresh.")

    def _save_notes(self):
        """Сохраняет кеш заметок в настройки."""
        self.set_setting("user_notes", json.dumps(self.pg_notes_cache))

    def _get_note_for_user(self, user_id: int) -> str:
        """Возвращает заметку для указанного ID пользователя."""
        return self.pg_notes_cache.get(user_id, "")

    def _set_note_for_user(self, user_id: int, note: str):
        """Устанавливает или удаляет заметку для пользователя."""
        if note:
            self.pg_notes_cache[user_id] = note
        elif user_id in self.pg_notes_cache:
            del self.pg_notes_cache[user_id]
        self._save_notes()

    # --- Создание UI элементов ---
    def _create_pinned_view(self, context: Context) -> FrameLayout:
        """Создает View, имитирующий закрепленное сообщение."""
        container = FrameLayout(context)
        container.setLayoutParams(FrameLayout.LayoutParams(-1, AndroidUtilities.dp(48)))
        
        background = GradientDrawable()
        background.setColor(Color.parseColor("#344658"))
        container.setBackground(background)

        line = View(context)
        line.setBackgroundColor(Color.parseColor("#74B4FF"))
        container.addView(line, FrameLayout.LayoutParams(AndroidUtilities.dp(2), -1))
        
        pin_icon = ImageView(context)
        pin_icon.setImageResource(R.drawable.msg_pin)
        pin_icon_params = FrameLayout.LayoutParams(AndroidUtilities.dp(24), AndroidUtilities.dp(24), Gravity.CENTER_VERTICAL)
        pin_icon_params.leftMargin = AndroidUtilities.dp(12)
        container.addView(pin_icon, pin_icon_params)
        
        text_view = TextView(context)
        text_view.setTextColor(Color.WHITE)
        text_view.setTextSize(14)
        text_view_params = FrameLayout.LayoutParams(-2, -2, Gravity.CENTER_VERTICAL)
        text_view_params.leftMargin = AndroidUtilities.dp(48)
        text_view_params.rightMargin = AndroidUtilities.dp(12)
        container.addView(text_view, text_view_params)
        
        container.setTag("pinned_note_view")
        container.setVisibility(View.GONE)
        
        return container

    def _create_input_view(self, context: Context, user_id: int, fragment: Any) -> LinearLayout:
        """Создает View с полем ввода и кнопкой сохранения."""
        container = LinearLayout(context)
        container.setOrientation(LinearLayout.HORIZONTAL)
        container.setGravity(Gravity.CENTER_VERTICAL)
        container.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(4), AndroidUtilities.dp(8), AndroidUtilities.dp(4))
        container.setLayoutParams(LinearLayout.LayoutParams(-1, AndroidUtilities.dp(48)))

        edit_text = EditText(context)
        edit_text.setHint("Введите локальную заметку...")
        edit_text.setTextColor(Color.WHITE)
        edit_text.setHintTextColor(Color.GRAY)
        edit_text.setTextSize(15)
        edit_text.setBackground(None)
        container.addView(edit_text, LinearLayout.LayoutParams(0, -2, 1.0))

        save_button = TextView(context)
        save_button.setText("SAVE")
        save_button.setTextColor(Color.parseColor("#527da3"))
        save_button.setTypeface(AndroidUtilities.getTypeface("fonts/rmedium.ttf"))
        save_button.setPadding(AndroidUtilities.dp(8), AndroidUtilities.dp(4), AndroidUtilities.dp(8), AndroidUtilities.dp(4))
        save_button.setOnClickListener(lambda view: self._on_save_clicked(user_id, edit_text, fragment))
        container.addView(save_button)
        
        container.setTag("input_note_view")
        return container

    def _on_save_clicked(self, user_id: int, edit_text: EditText, fragment: Any):
        """Обработчик нажатия на кнопку 'SAVE'."""
        note_text = edit_text.getText().toString().strip()
        self._set_note_for_user(user_id, note_text)
        
        self.update_ui_for_fragment(fragment)
        
        AndroidUtilities.hideKeyboard(edit_text)
        BulletinHelper.show_success(LocaleController.getString("NoteSaved", R.string.NoteSaved) or "Note saved")

    def update_ui_for_fragment(self, fragment: Any):
        """Обновляет UI для данного фрагмента."""
        fragment_hash = hash(fragment)
        if fragment_hash not in self.injected_views:
            return
            
        views = self.injected_views[fragment_hash]
        pinned_view = views.get("pinned")
        input_edit_text = views.get("input_edit_text")
        
        user_id = get_private_field(fragment, "user_id")
        if not user_id or user_id < 0: return
            
        note = self._get_note_for_user(user_id)

        if pinned_view:
            text_view = pinned_view.getChildAt(2)
            if note:
                text_view.setText(note)
                pinned_view.setVisibility(View.VISIBLE)
            else:
                pinned_view.setVisibility(View.GONE)
        
        if input_edit_text:
            input_edit_text.setText(note)


class ProfileCreateViewHook(MethodHook):
    def __init__(self, plugin: ProfileNotesPlugin):
        super().__init__()
        self.plugin = plugin

    def after_hooked_method(self, param: Any):
        try:
            fragment = param.thisObject
            fragment_hash = hash(fragment)

            user_id = get_private_field(fragment, "user_id")
            if not user_id or user_id < 0: return

            if fragment_hash in self.plugin.injected_views:
                self.plugin.update_ui_for_fragment(fragment)
                return

            context = param.args[0]
            
            # --- Самый надежный способ: найти блок с информацией и добавить View после него ---
            # 'aboutTextView' (поле "о себе") - надежный якорь в разметке.
            about_text_view = get_private_field(fragment, "aboutTextView")
            if not about_text_view:
                self.plugin.log("Could not find 'aboutTextView' to inject notes UI.")
                return

            parent_layout = about_text_view.getParent()
            if not isinstance(parent_layout, ViewGroup):
                self.plugin.log("Parent of 'aboutTextView' is not a ViewGroup.")
                return

            # Создаем один контейнер для всех наших UI-элементов
            notes_container = LinearLayout(context)
            notes_container.setOrientation(LinearLayout.VERTICAL)
            
            pinned_view = self.plugin._create_pinned_view(context)
            input_view = self.plugin._create_input_view(context, user_id, fragment)

            notes_container.addView(pinned_view)
            notes_container.addView(input_view)
            
            # Добавляем отступ сверху для визуального разделения
            params = LinearLayout.LayoutParams(-1, -2)
            params.topMargin = AndroidUtilities.dp(8)
            notes_container.setLayoutParams(params)

            # Находим индекс 'aboutTextView' и вставляем наш контейнер сразу после него
            index_of_about = parent_layout.indexOfChild(about_text_view)
            parent_layout.addView(notes_container, index_of_about + 1)
            
            # Сохраняем ссылки на созданные View для будущего управления
            # #>^_^<#
            self.plugin.injected_views[fragment_hash] = {
                "container": notes_container,
                "pinned": pinned_view,
                "input_edit_text": input_view.getChildAt(0)
            }
            
            # Загружаем текущую заметку в UI
            self.plugin.update_ui_for_fragment(fragment)

        except Exception as e:
            self.plugin.log(f"Error in ProfileCreateViewHook: {e}\n{traceback.format_exc()}")


class ProfileDestroyHook(MethodHook):
    def __init__(self, plugin: ProfileNotesPlugin):
        super().__init__()
        self.plugin = plugin

    def before_hooked_method(self, param: Any):
        try:
            fragment = param.thisObject
            fragment_hash = hash(fragment)

            if fragment_hash in self.plugin.injected_views:
                views = self.plugin.injected_views[fragment_hash]
                
                # Корректно удаляем наш контейнер из родительского layout
                if (container := views.get("container")) and (parent := container.getParent()):
                    if isinstance(parent, ViewGroup):
                        parent.removeView(container)
                
                del self.plugin.injected_views[fragment_hash]
                self.plugin.log(f"Cleaned up UI for fragment {fragment_hash}")

        except Exception as e:
            self.plugin.log(f"Error in ProfileDestroyHook: {e}\n{traceback.format_exc()}")